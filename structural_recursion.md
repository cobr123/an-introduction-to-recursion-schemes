[English version (origin)](https://nrinaudo.github.io/recschemes/structural_recursion.html)

[Назад](./recursive_data_types.md) | [Оглавление](./README.md) | [Дальше](./fold.md)

# Структурная рекурсия

Теперь, когда у нас есть рекурсивный тип данных - мономорфный список - мы можем начать с ним работать. Интуитивно вы можете понять, что если мы работаем с рекурсивными типами, мы, вероятно, обратимся к рекурсивным алгоритмам.

Существуют различные общие стратегии управления рекурсивными типами, каждая из которых предназначена для решения определенного типа задач. В первую очередь мы рассмотрим структурную рекурсию, которая является наиболее распространенной: это форма рекурсии, в которой вы позволяете структуре вашего типа направлять вас.

## Произведение

Мы могли бы, например, вычислить произведение нашего списка. Вот наивная реализация:

```scala
def product(
  values: List
): Int =
  values match {
    case Cons(head, tail) => head * product(tail)
    case Nil              => 1
  }
```

Пуристы будут жаловаться, что для достаточно больших списков это вызовет исключение во время выполнения: эту реализацию мы называем небезопасной для стека, потому что каждый шаг в рекурсии потребляет фрейм стека, и в конечном итоге мы потребляем больше, чем доступно. У этой проблемы есть решения, но они могут сделать код немного неудобным, поэтому для ясности мы сделаем вид, что проблем со стеком не существует.

Эта функция следует структуре своего входного списка:
- если встретили `Cons`, умножаем `head` на произведение `tail`.
- если встретили `Nil`, используем нейтральный элемент для умножения: `1`.

Это в конечном итоге превращает наш список в `3 * 2 * 1 * 1`, это именно тот результат, который мы искали:

```scala
product(ints)
// res0: Int = 6
```


И если вы посмотрите на это с более высокой точки зрения, мы делаем следующее:
- предоставляем решение наименьшей возможной задачи, пустой список
- остальное разбиваем на более мелкие части: меньший список (`tail`), и дополнительные данные (`head`).

## Строковое представление

Этот шаблон возникает постоянно. Представьте, например, что вы хотите вычислить строковое представление списка.

```scala
def mkString(
  values: List
): String =
  values match {
    case Cons(head, tail) => head + " :: " + mkString(tail)
    case Nil              => "nil"
  }
```

Мы делаем то же самое:
- решение для `Nil` это `"nil"`
- остальное разбивается на `head` и `tail`, и мы объединяем их соответствующие строковые представления, разделенные`" :: "`


## Ключевые выводы

Важные части структурной рекурсии:
- наименьшая возможная задача, которую мы должны решить
- остальные задачи состоят из:
  - меньшая задача, которую мы предполагаем, что у нас есть решение
  - дополнительная информация, которую мы используем для обновления решения меньшей задачи

Если это заставляет вас думать о доказательстве по индукции, это, конечно, вовсе не совпадение.

Поскольку структурная рекурсия состоит из набора четко определенных частей, наша следующая задача будет заключаться в том, чтобы абстрагироваться от общего кода и позволить себе сконцентрироваться только на интересном.

[Назад](./recursive_data_types.md) | [Оглавление](./README.md) | [Дальше](./fold.md)

This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
